# 并发

## 锁

```java
1.内部有实现了分布式锁的类：com.ctgcd.clouddesktop.pubserv.util.SimpleDistributeLockUtil#getLockInstance
注意这个分布式锁的实现类有以下缺点
（1）是非公平锁，没有实现可重入机制
（2）尚未对锁过期进行续期处理，对于锁过期后，业务尚未执行完的极端情况（如db io时间过长，远程调用时间过长）等情况，锁自然过期，导致任然存在并发安全问题。

最佳实现
Lock lock = SimpleDistributeLockUtil.getLockInstance(lockName);
try {
    if (lock.tryLock()) {
        ...
    }else{
        log.warn(...);
    }
}finally {
    lock.unlock();
}
错误实践
boolean setSuc = redisTemplate.opsForValue().setIfAbsent(lockKey, vs, "1");
redisTemplate.expire(lockKey, timeout, TimeUnit.MINUTES);
try {
    if (setSuc) {
        ...
    }else(){
        ...
    }
} finally {
    redisTemplate.delete(lockKey);
}
这段逻辑问题在于在：ab线程抢占，a抢到了正在执行临界区代码。b没抢到会会执行finally代码，直接将锁释放掉。
但是Lock接口的锁没有这个问题。这是因为Lock的实现（如ReentrantLock）设计为线程安全的。在释放锁的手会判断是不是当前线程持有的锁。
    

```

## 公平锁和非公平锁

公平锁：按照线程请求锁的顺序来获取锁，确保先来先服务，避免线程饥饿

- 优点：所有的线程都能得到资源，不会饿死在队列中。
- 缺点：吞吐量会下降很多，队列里面除了第一个线程，其他的线程都会阻塞，cpu唤醒阻塞线程的开销会很大。

非公平锁：多个线程获取锁的顺序是不确定的，新请求的线程有可能直接获取到锁

- 优点：可以减少CPU唤醒线程的开销，整体的吞吐效率会高点，CPU也不必取唤醒所有线程，会减少唤起线程的数量。
- 缺点：你们可能也发现了，这样可能导致队列中间的线程一直获取不到锁或者长时间获取不到锁，导致饿死。

## redission

**1. 简单易用**

简洁的 API：Redisson 提供了一套简洁直观的 Java API 来操作分布式锁，开发人员只需进行少量的代码编写就能轻松实现分布式锁的获取、释放等功能。

**2. 高可靠性**

基于 Redis 的持久化机制：Redis 本身支持多种持久化方式（如 RDB、AOF），即使在 Redis 服务出现短暂重启等情况，分布式锁的相关信息也有一定几率能够基于这些持久化数据得以恢复，保障锁机制的持续有效性。

集群环境支持良好：Redisson 可以在 Redis 集群环境下正常工作，无论是主从模式、哨兵模式还是 Redis Cluster 模式，都能确保分布式锁功能稳定可靠，有效应对单点故障等问题，提升整体系统的可用性。

**3. 支持可重入性**

支持同一线程多次获取锁：和 Java 内置的锁机制类似，Redisson 实现的分布式锁允许同一线程多次获取同一把锁，只要每次获取后按照规则释放锁即可

**4. 阻塞与非阻塞获取模式**

阻塞获取：可以通过 lock()， 非阻塞获取：利用 tryLock() 

**5. 公平锁与非公平锁支持**

**6. 锁续期功能（Watch Dog 机制）**

如果未显式设置过期时间，Redisson 会启动后台线程（WatchDog）定期续期

# 线程池

## 数据库连接池Druid

当我们有了连接池，应用程序启动时就预先建立多个数据库连接对象，然后将连接对象保存到连接池中。当客户请求到来时，从池中取出一个连接对象为客户服务。当请求完成时，客户程序调用关闭方法，将连接对象放回池中.可以**资源复用**，**连接管理**

可以配置sql监控。

# spring

@Tarnsaction注解失效场景：

1. 事务方法内部捕获并处理了异常，没有将异常抛出，事务不会回滚。
2. 在同一个类中的非事务方法调用事务方法，或者事务方法内部调用另一个事务方法，由于没有经过Spring AOP代理，事务将失效。
3. 方法被final、static修饰，或者不是public方法，事务将失效

## 初始化任务

在应用程序启动后执行初始化任务可以通过ApplicationRunner接口实现

## 异常类

你真的需要一种处理异常的一致方法。Spring Boot提供了三种方法：

（1）注解ExceptionHandler，再方法上使用，比较局限。

（2）继承HandlerExceptionResolver接口

（3）注解ControllerAdvice

ControllerAdvice和ExceptionHandler配合可以做到全局异常处理,使用@Order可以指定执行顺序

```java
@ControllerAdvice
@Order(1)
public class GlobalExceptionHandler {
    
    // 处理特定异常
    @ExceptionHandler(ResourceNotFoundException.class)
    @ResponseStatus(HttpStatus.NOT_FOUND)
    public ResponseEntity<ErrorResponse> handleResourceNotFound(
            ResourceNotFoundException ex) {
        ErrorResponse error = new ErrorResponse(
            "NOT_FOUND",
            ex.getMessage(),
            new Date()
        );
        return new ResponseEntity<>(error, HttpStatus.NOT_FOUND);
    }
    
    // 处理多个异常
    @ExceptionHandler({ 
        IllegalArgumentException.class, 
        IllegalStateException.class 
    })
    public ResponseEntity<ErrorResponse> handleBadRequest(Exception ex) {
        // 处理逻辑
    }
}

可以捕捉到错误可以打印日志，将请求url，参数信息，tranceid打印出来
```

全局异常处理对比

| 特性           | HandlerExceptionResolver    | @ControllerAdvice + @ExceptionHandler |
| :------------- | :-------------------------- | :------------------------------------ |
| **控制粒度**   | 完全控制请求/响应           | 只能控制返回内容                      |
| **执行顺序**   | 可以精确控制优先级          | 通过 @Order 控制                      |
| **访问权限**   | 可访问所有Servlet API       | 有限访问（通过参数注入）              |
| **配置方式**   | 编程式配置                  | 声明式注解                            |
| **测试难度**   | 较难（需要模拟Servlet对象） | 较易（直接测试方法）                  |
| **灵活性**     | 极高                        | 高                                    |
| **代码简洁性** | 较低                        | 高                                    |
| **适用场景**   | 需要复杂异常处理逻辑        | 大多数业务异常处理                    |

https://juejin.cn/post/6844903768421564429?searchId=202512171052480172E8D0B49D4FAB27EB#heading-4

# 安全

## 加密和解密

1.对称加密算法：加密和解密用的相同密钥，典型有DES/AES/RC2/RC4 ，主要用**AES**

2.非对称加密算法：有私钥和公钥，典型算法有**RSA**

3.散列算法(摘要算法)：散列算法（消息摘要算法、签名算法）是单向不可逆的，无法通过加密后的散列值反推原始值，相同的内容用同样的摘要算法获得的散列值是一样的，所以常用于验证数据的完整性。主要用**MD5**

# Sentinel

# java8

## Optional

```java
作用：安全的链式调用（避免深层嵌套的 null 检查）
public class Address {
    private String city;
    // getter 和 setter
}

public class User {
    private Address address;
    // getter 和 setter
}

// 传统方式：令人头疼的深层 null 检查
public String getUserCity(User user) {
    if (user != null) {
        Address address = user.getAddress();
        if (address != null) {
            return address.getCity(); // 可能还是null
        }
    }
    return "未知";
}

// 使用 Optional.ofNullable：清晰且扁平化
public String getUserCity(User user) {
    return Optional.ofNullable(user)         // 如果user为null，后面全跳过
            .map(User::getAddress)           // 如果getAddress()返回null，后面全跳过
            .map(Address::getCity)           // 如果getCity()返回null，结果就是空Optional
            .orElse("未知");                 // 如果上述任何一步为空，则返回“未知”
}
```



# 场景题分析 
